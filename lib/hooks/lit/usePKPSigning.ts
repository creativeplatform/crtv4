/**
 * @file usePKPSigning.ts
 * @description React hook for PKP (Programmable Key Pair) signing operations using Lit Protocol.
 *
 * This hook provides functionality for:
 * - Signing arbitrary messages using a PKP (Programmable Key Pair)
 * - Signing transactions with a PKP
 * - Executing custom Lit Actions for complex signing operations
 *
 * The signing process works by:
 * 1. Connecting to the Lit Network
 * 2. Formatting the message or transaction for signing
 * 3. Executing a Lit Action with the provided authentication signatures
 * 4. Returning the signature generated by the PKP on the Lit Network
 *
 * @requires LitNodeClient from @lit-protocol/lit-node-client
 * @requires useUser from @account-kit/react for account type validation
 * @requires viem utilities for formatting messages (keccak256, toBytes)
 * @requires zod for runtime validation of parameters
 *
 * @param {SignParams} params The parameters for the signing operation:
 *   - message: The message to sign
 *   - publicKey: The PKP public key
 *   - sigName: Name for the signature (default: "sig1")
 *   - authSig: Authentication signatures from Lit Protocol
 *   - litActionCode: Custom Lit Action code (optional)
 *   - ipfsId: IPFS ID of a stored Lit Action (optional)
 *
 * @returns {Object} An object containing:
 *   - signWithPKP: Function to sign a message with a PKP
 *   - signTransaction: Function to sign a transaction with a PKP
 *
 * @example
 * // Sign a message
 * const { signWithPKP } = usePKPSigning();
 * const result = await signWithPKP({
 *   message: "Hello, world!",
 *   publicKey: "0x...",
 *   authSig: sessionSigs,
 *   litActionCode: customCode // optional
 * });
 *
 * // Sign a transaction
 * const { signTransaction } = usePKPSigning();
 * const txResult = await signTransaction({
 *   transaction: {
 *     to: "0x...",
 *     value: BigInt("1000000000000000"),
 *     data: "0x",
 *   },
 *   publicKey: "0x...",
 *   authSig: sessionSigs,
 * });
 *
 * @dev Notes:
 * - Uses the Lit Datil network by default
 * - Requires a Smart Contract Account (SCA) user type
 * - The DEFAULT_LIT_ACTION_CODE provides standard ECDSA signing functionality
 * - Custom Lit Actions can be provided for more complex signing requirements
 * - Properly formats message bytes using keccak256 hashing
 * - Transaction signing serializes the transaction parameters before signing
 * - Either litActionCode or ipfsId must be provided (default code used if not specified)
 * - The authSig parameter must be valid session signatures from Lit Protocol
 */

import { useCallback } from "react";
import { keccak256, toBytes } from "viem";
import { z } from "zod";
import { useUser } from "@account-kit/react";
import { LitNodeClient } from "@lit-protocol/lit-node-client";
import { LIT_NETWORK } from "@lit-protocol/constants";

const DEFAULT_LIT_ACTION_CODE = `
const go = async () => {
  // Ensure toSign is properly formatted
  const messageToSign = typeof toSign === 'string' ? 
    ethers.utils.arrayify(ethers.utils.keccak256(ethers.utils.toUtf8Bytes(toSign))) :
    toSign;
    
  const sigShare = await Lit.Actions.signEcdsa({ 
    toSign: messageToSign,
    publicKey, 
    sigName,
    shouldHashMessage: true,
    sigType: "ethereum",
  });
  return sigShare;
}
go()
`;

const SignParamsSchema = z
  .object({
    message: z.string(),
    publicKey: z.string(),
    sigName: z.string().default("sig1"),
    authSig: z.any(), // Type will come from your auth context
    litActionCode: z.string().optional(),
    ipfsId: z.string().optional(),
  })
  .refine(
    (params) => !!(params.litActionCode || params.ipfsId),
    "Either litActionCode or ipfsId must be provided"
  );

export type SignParams = z.infer<typeof SignParamsSchema>;

export interface SignResult {
  success: boolean;
  signatures?: any; // Will be properly typed once we have the full signature format
  error?: string;
}

export interface TransactionSignParams extends SignParams {
  transaction: {
    to: string;
    value: bigint;
    data: string;
    nonce?: number;
    maxFeePerGas?: bigint;
    maxPriorityFeePerGas?: bigint;
    gasLimit?: bigint;
  };
}

export function usePKPSigning() {
  const user = useUser();

  const initializeLitClient = useCallback(async (): Promise<LitNodeClient> => {
    const client = new LitNodeClient({
      litNetwork: LIT_NETWORK.Datil,
      debug: false,
    });
    await client.connect();
    return client;
  }, []);

  const signWithPKP = useCallback(
    async ({
      message,
      publicKey,
      sigName = "sig1",
      authSig,
      litActionCode = DEFAULT_LIT_ACTION_CODE,
      ipfsId,
    }: SignParams): Promise<SignResult> => {
      if (!user?.type || user.type !== "sca") {
        return {
          success: false,
          error: "Smart Contract Account required for Lit Protocol signing",
        };
      }

      console.log("Initializing PKP signing with:", {
        messageLength: message.length,
        publicKey,
        sigName,
        hasAuthSig: !!authSig,
        hasIpfsId: !!ipfsId,
      });

      try {
        const client = await initializeLitClient();

        const params = SignParamsSchema.parse({
          message,
          publicKey,
          sigName,
          authSig,
          litActionCode,
          ipfsId,
        });

        // Properly format the message for signing
        const messageBytes = toBytes(keccak256(toBytes(message)));

        console.log(
          "Executing Lit Action for signing with formatted message:",
          {
            messageBytes: messageBytes.slice(0, 10).toString() + "...",
            publicKey: publicKey.slice(0, 10) + "...",
            sigName,
          }
        );

        const signatures = await client.executeJs({
          code: params.litActionCode,
          ipfsId: params.ipfsId,
          sessionSigs: params.authSig,
          jsParams: {
            toSign: messageBytes,
            publicKey: params.publicKey,
            sigName: params.sigName,
          },
        });

        // Validate signature format
        if (!signatures || typeof signatures !== "object") {
          throw new Error("Invalid signature format returned from Lit Action");
        }

        return {
          success: true,
          signatures,
        };
      } catch (error) {
        console.error("PKP signing failed:", error);
        return {
          success: false,
          error: error instanceof Error ? error.message : "PKP signing failed",
        };
      }
    },
    [user?.type, initializeLitClient]
  );

  const signTransaction = useCallback(
    async ({
      transaction,
      publicKey,
      authSig,
    }: TransactionSignParams): Promise<SignResult> => {
      try {
        // Serialize transaction data
        const serializedTx = {
          to: transaction.to,
          value: transaction.value.toString(),
          data: transaction.data,
          nonce: transaction.nonce,
          maxFeePerGas: transaction.maxFeePerGas?.toString(),
          maxPriorityFeePerGas: transaction.maxPriorityFeePerGas?.toString(),
          gasLimit: transaction.gasLimit?.toString(),
        };

        // Create transaction signing code
        const txSigningCode = `
const go = async () => {
  // Serialize and sign the transaction
  const tx = ${JSON.stringify(serializedTx)};
  
  const sigShare = await Lit.Actions.signEcdsa({
    toSign: tx,
    publicKey,
    sigName: "txSig",
    shouldHashMessage: true,
    sigType: "ethereum",
  });
  
  return sigShare;
}
go();
`;

        // Sign the transaction using PKP
        return signWithPKP({
          message: JSON.stringify(serializedTx),
          publicKey,
          sigName: "txSig",
          authSig,
          litActionCode: txSigningCode,
        });
      } catch (error) {
        console.error("Transaction signing failed:", error);
        return {
          success: false,
          error:
            error instanceof Error
              ? error.message
              : "Transaction signing failed",
        };
      }
    },
    [signWithPKP]
  );

  return {
    signWithPKP,
    signTransaction,
  };
}
